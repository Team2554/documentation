---
sidebar_label: Intro
sidebar_position: 1
---

# FRC-2020 Repository Documentation

### The Infinite Recharge Robot

import ThemedImage from '@theme/ThemedImage';
import useBaseUrl from '@docusaurus/useBaseUrl';

<ThemedImage
alt="Docusaurus themed image"
sources={{
    light: useBaseUrl('/img/programming/repos/frc-2020/robot-anno-light.png'),
    dark: useBaseUrl('/img/programming/repos/frc-2020/robot-anno-dark.png'),
  }}
/>

This is the robot we built for the Infinite Recharge challenge. Before reading this documentation, go look at the [game animation for Infinite Recharge](https://www.youtube.com/watch?v=gmiYWTmFRVE&t).

### Introduction to the robot code

The goal of the robot code is to provide an easy way to control all of the motors on the robot and also run the motor autonomously. In order to accomplish this, we use the command-based architecture for the robot code. The code is made up of the following subsystems:

- DriveTrain
- Intake
- TopConveyor
- BottomConveyor
- Shooter
- Vision
- Elevator
- ColorWheel

They all are described in detail in the subsystems page.

In order to perform specific actions on each of the subsytems, we have commands, which are eventually bound to user input. In the repository, the commands are organized by subsystem. There are also some command groups, which are used to perform multiple commands in a certain order, either in parrallel or in series. All the commands are described in detail in the commands page.

### The driver station

### Robot.java

Next up, `Robot.java`. Most of this file is also autogenerated, and it used to be useful before the new command based system. Now, however, it's just used for some basic initialization tasks and other miscellaneous stuff.

The `robotInit()` function is the first function that is called when the robot is started up. The first thing that is initialized is `RobotContainer m_robotContainer`. The `RobotContainer` class is defined in `RobotContainer.java`, which we will discuss later. For now, all you need to know is that all the driver input for the robot is defined in `RobotContainer`. The `m_robotContainer` object is defined at the start of the class.

The next line initializes the camera. This is not the vision camera, but rather the camera that is displayed to the driver on the driver station. Next, we set the camera resolution to 426x240. The camera is set to a low resolution because, during an FRC competition, we are only alloted a certain amount of bandwidth, and if we send a camera stream that is too high resolution, our camera connection might drop too much, making it harder to drive. We need to prioritize framerate over visual quality.

Next up is the `robotPeriodic()` function. This function is called every tick on the robot, no matter what mode the robot is set to(disabled, teleop, auto, test). Basically, it's a while loop. The function only has one line, `CommandScheduler.getInstance().run()`. In a command-baesd codebase, the command scheduler is responsible for reciving driver input and calling the commands as defined in `RobotContainer`, so with this line, we are telling the command scheduler to do whatever it's supossed to do every tick.

The next two functions are `disabledInit()` and `disabledPeriodic()`. `disabledInit()` is called when the robot is set disabled mode on the driver station and the periodic function is called every tick only when the robot is disabled. **_Note that all the robot modes are set in driver station_**. Both the functions are empty because we don't want anything to happen during disabled mode. Do note however, that the command scheduler, which is being run in `robotPeriodic()`, is still being called. The code in `robotPeriodic()` is always being run, no matter the mode.

Next comes `autonomousInit()` and `autonomousPeriodic()`. The init function checks the `m_robotContainer` to see if an autonomous command is set, and if the command is not null, it schedules it. Autonomous periodic is empty because there is nothing we need to do there. Everything is handled in whatever autonomous command is being run.

Next is `teleopInit()` and `teleopPeriodic()`. `teleopInit()` just cancels the autonomous command because we can use user input instead in the teleoperated section. There's a commented out `resetGyro()` call(the gyro is a sensor that tells us what angle we are currently at), and the reason it was commented out is because you don't know if the robot is pointing forward after autonomous. Also, we don't really need absolute gyro values in teleoperated mode anyways. The periodic function is empty because all the user input is handled by the scheduler, which is always being called by `robotPeriodic()`.

Finally there's `testInit()` and `testPeriodic()`. We don't really use these, but all `testInit()` does is cancel all currently running commands, whatever they might be. More code can be added here for testing, and you don't need to worry about removing it because the test mode is never activated during an actual competition. This section could be useful for testing and debugging at a competition pit.